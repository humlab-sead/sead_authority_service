
language_detection: |
  Detect the language of the following text. Respond with the ISO 639-1 language code (e.g., "en" for English, "fr" for French, "de" for German, "sv" for Swedish).

  Text:
  "{text}"

translation: |
  Translate the following text line by line from {source_lang} to {target_lang}.

  Context:
  {context}

  Guidelines:
  - Keep the translation natural and fluent.
  - Preserve proper nouns, names, and technical terms when appropriate.
  - Use the most common or widely recognized form in the target language if one exists.
  - Maintain the same number of lines as the input.

  Text to translate:
  {text}

abbreviation: |
  Expand the following abbreviations line by line.

  Each line in the input follows the format:
  "id, abbreviation"

  The text may include multiple languages.
  
  {context}

  Your task:
  - Expand each abbreviation into its full form based on the given context.
  - Preserve proper nouns, names, and original capitalization when appropriate.
  - Output one line per input line, using the format:
    "id, expanded-abbreviation"

  Input abbreviations:
  {data}

reconciliation: |
  You are reconciling input values against a controlled list of {{ entity_type }}.
  Return ONLY strict JSON. No prose.

  Context:
  {{ context }}

  Lookup data ({{ lookup_format }} objects with fields: id, label, description):
  {{ lookup_data | safe }}

  Input values ({{ lookup_format }}, preserve order):
  {{ data | safe }}

  Task:
  For each input, return up to 5 candidate matches from the lookup, ordered best→worst.

  Output JSON must be an array where each element is:
  {
    "input_id": "<string>",
    "input_value": "<string>",
    "candidates": [
      { "id": "<lookup id as string>", "value": "<lookup label verbatim>", "score": 0.00, "reasons": ["...","..."] }
    ]
  }

  {{ examples | safe }}

  Rules:
  - Use ONLY ids/labels from the lookup (do not invent).
  - Copy the lookup's **label** into the candidate **value** verbatim.
  - If no reasonable match, return "candidates": [].
  - Scores are in [0,1], **rounded to two decimals**.
  - Provide **2–4 short** reason bullets per candidate.
  - Treat text comparison as **case- and diacritic-insensitive**.
  - Return **ONLY** valid JSON (no comments, no trailing commas, no extra text).

  Scoring considerations:
  - String similarity (normalization, diacritics, casing)
  - Abbreviation/alias/lemmatization expansion
  - Domain/context alignment (terminology fit)
  - Language variants and most common target-language form
  - Penalize partial/ambiguous overlaps and mismatched domain terms
