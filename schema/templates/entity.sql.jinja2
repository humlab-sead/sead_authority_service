/**********************************************************************************************
 ** Table  authority.{{ entity_key }}_embeddings
 ** Note   Embeddings side table for {{ entity.name }} in schema authority
 **        Used for semantic search with pgvector
 **        Generated from template by generate_entity_schema.py
 **********************************************************************************************/

drop table if exists authority.{{ entity_key }}_embeddings cascade;

create table if not exists authority.{{ entity_key }}_embeddings (
  {{ entity.id_column }} integer primary key references public.{{ entity.table_name }}({{ entity.id_column }}) on delete cascade,
  emb vector({{ embedding_config.dimension | default(768) }})
);

-- Vector index for fast ANN search (cosine). Tune lists to your row count.
create index if not exists {{ entity_key }}_embeddings_ivfflat
  on authority.{{ entity_key }}_embeddings
    using ivfflat (emb vector_cosine_ops)
      with (lists = {{ embedding_config.ivfflat_lists | default(100) }});

{%- if embedding_config.analyze | default(false) %}

analyze authority.{{ entity_key }}_embeddings;
{%- endif %}

/***************************************************************************************************
 ** Procedure  authority.update_{{ entity_key }}_embeddings
 ** What       Updates embeddings in authority.{{ entity_key }}_embeddings table
 ** Usage      SELECT authority.update_{{ entity_key }}_embeddings();        -- Update only missing
 **            SELECT authority.update_{{ entity_key }}_embeddings(true);    -- Force update all
 ** Arguments  p_force_update: If true, regenerate all embeddings; if false (default), only compute missing ones
 ** Returns    Number of rows updated
 ****************************************************************************************************/
 
drop function if exists authority.update_{{ entity_key }}_embeddings(boolean) cascade;

create or replace function authority.update_{{ entity_key }}_embeddings(
  p_force_update boolean default false
) returns integer
language plpgsql volatile
as $$
declare
  rec record;
  v_emb vector({{ embedding_config.dimension | default(768) }});
  v_text text;
  v_rows_updated integer := 0;
begin
  raise notice 'Updating {{ entity_key }} embeddings (force_update: %)', p_force_update;
  
  for rec in
    select t.{{ entity.id_column }},
           t.{{ entity.label_column }}{% if entity.description_column %},
           t.{{ entity.description_column }}{% endif %}
    from public.{{ entity.table_name }} t
    where p_force_update 
       or not exists (
         select 1 from authority.{{ entity_key }}_embeddings e 
         where e.{{ entity.id_column }} = t.{{ entity.id_column }}
       )
  loop
    -- Construct text for embedding (combine label and description if available)
    v_text := rec.{{ entity.label_column }};
{%- if entity.description_column %}
    if rec.{{ entity.description_column }} is not null then
      v_text := v_text || ' ' || rec.{{ entity.description_column }};
    end if;
{%- endif %}
    
    -- Compute embedding (assumes authority.compute_text_embedding exists)
    v_emb := authority.compute_text_embedding(v_text);
    
    -- Upsert into embeddings table
    insert into authority.{{ entity_key }}_embeddings ({{ entity.id_column }}, emb)
    values (rec.{{ entity.id_column }}, v_emb)
    on conflict ({{ entity.id_column }}) do update
      set emb = excluded.emb;
    
    v_rows_updated := v_rows_updated + 1;
    
    -- Progress reporting every 100 rows
    if v_rows_updated % 100 = 0 then
      raise notice '  → Processed % rows', v_rows_updated;
    end if;
  end loop;
  
  raise notice 'Completed: % rows updated for {{ entity_key }}', v_rows_updated;
  return v_rows_updated;
end;
$$;

/**********************************************************************************************
**  {{ entity.name }}
**********************************************************************************************/

{%- if embedding_config.materialized | default(false) %}

drop materialized view if exists authority.{{ entity_key }} cascade;

create materialized view authority.{{ entity_key }} as
{%- else %}

drop view if exists authority.{{ entity_key }} cascade;

create or replace view authority.{{ entity_key }} as
{%- endif %}
  select
    t.{{ entity.id_column }},
    t.{{ entity.label_column }} as label,
    authority.immutable_unaccent(lower(t.{{ entity.label_column }})) as norm_label,
{%- if entity.description_column %}
    t.{{ entity.description_column }},
{%- endif %}
{%- if entity.alternate_identity_column %}
    t.{{ entity.alternate_identity_column }},
{%- endif %}
{%- for col in embedding_config.extra_columns | default([]) %}
    {{ col }},
{%- endfor %}
    e.emb
  from public.{{ entity.table_name }} as t
{%- for join in embedding_config.joins | default([]) %}
  {{ join }}
{%- endfor %}
{%- if embedding_config.where_clause %}
  where {{ embedding_config.where_clause }}
{%- endif %}
  left join authority.{{ entity_key }}_embeddings as e using ({{ entity.id_column }});

{%- if embedding_config.materialized | default(false) %}

-- Required to allow REFRESH MATERIALIZED VIEW CONCURRENTLY
create unique index if not exists {{ entity_key }}_uidx
  on authority.{{ entity_key }} ({{ entity.id_column }});

-- Trigram index must be on the MV column we filter with (%), not on base table.
create index if not exists {{ entity_key }}_norm_trgm
  on authority.{{ entity_key }}
    using gin (norm_label gin_trgm_ops);

-- Vector search (semantic) on the MV
create index if not exists {{ entity_key }}_vec_ivfflat
  on authority.{{ entity_key }}
    using ivfflat (emb vector_cosine_ops)
      with (lists = {{ embedding_config.ivfflat_lists | default(100) }});

-- (First-time populate)
-- refresh materialized view concurrently authority.{{ entity_key }};
-- analyze authority.{{ entity_key }};
{%- else %}

create index if not exists {{ entity.table_name }}_norm_trgm
  on public.{{ entity.table_name }}
    using gin ( (authority.immutable_unaccent(lower({{ entity.label_column }}))) gin_trgm_ops );
{%- endif %}

/***************************************************************************************************
 ** Procedure  authority.fuzzy_{{ entity_key }}
 ** What       Trigram fuzzy search function using pg_trgm similarity
 ** Usage      SELECT * FROM authority.fuzzy_{{ entity_key }}('query text', 10);

{%- if embedding_config.filter_params %}
 ** Params     {% for param in embedding_config.filter_params %}{{ param.name }}: {{ param.description | default('filter parameter') }}{% if not loop.last %}, {% endif %}{% endfor %}
{%- endif %}
 ****************************************************************************************************/

drop function if exists authority.fuzzy_{{ entity_key }}(text, integer{% for param in embedding_config.filter_params | default([]) %}, {{ param.type }}{% endfor %}) cascade;

create or replace function authority.fuzzy_{{ entity_key }}(
  p_text text,
  p_limit integer default 10{% for param in embedding_config.filter_params | default([]) %},
  {{ param.name }} {{ param.type }} default {{ param.default }}{% endfor %}
) returns table (
  {{ entity.id_column }} integer,
  label text,
  name_sim double precision
) language sql stable
as $$
  with params as (
    select authority.immutable_unaccent(lower(p_text))::text as q
  )
{%- if embedding_config.filter_params %}
  , filter_params as (
{%- for param in embedding_config.filter_params %}
    {{ param.cte_definition | indent(4) }}{% if not loop.last %},{% endif %}
{%- endfor %}
  )
{%- endif %}
  select
    s.{{ entity.id_column }},
    s.label,
    greatest(
      case when s.norm_label = pq.q then 1.0
          else similarity(s.norm_label, pq.q)
      end, 0.0001
    ) as name_sim
  from authority.{{ entity_key }} as s
  cross join params pq
{%- if embedding_config.filter_params %}
{%- for param in embedding_config.filter_params %}
  {{ param.join_clause | indent(2) }}
{%- endfor %}
{%- endif %}
  where s.norm_label % pq.q
{%- if embedding_config.filter_params %}
{%- for param in embedding_config.filter_params %}
    {{ param.where_clause | indent(4) }}
{%- endfor %}
{%- endif %}
  order by name_sim desc, s.label
  limit p_limit;
$$;

/***************************************************************************************************
 ** Procedure  authority.semantic_{{ entity_key }}
 ** What       Semantic search function using pgvector embeddings
 ** Usage      SELECT * FROM authority.semantic_{{ entity_key }}(qemb::vector, 10);
 ****************************************************************************************************/

drop function if exists authority.semantic_{{ entity_key }}(vector, integer) cascade;

create or replace function authority.semantic_{{ entity_key }}(
  qemb vector,
  p_limit integer default 10
) returns table (
  {{ entity.id_column }} integer,
  label text,
  sem_sim double precision
) language sql stable
as $$
  select
    e.{{ entity.id_column }},
    e.label,
    1.0 - (e.emb <=> qemb) as sem_sim
  from authority.{{ entity_key }} as e
  where e.emb is not null
  order by e.emb <=> qemb
  limit p_limit;
$$;

/***************************************************************************************************
 ** Procedure  authority.search_{{ entity_key }}_hybrid
 ** What       Hybrid search combining trigram and semantic search
 ** Notes      See docs/MCP Server/SEAD Reconciliation via MCP — Architecture Doc (Outline).md
 ** Arguments
 **            p_text: raw query text
 **            qemb:  query embedding (same dim as stored vectors)
 **            k_trgm: number of trigram results to return (default 30)
 **            k_sem:  number of semantic results to return (default 30)
 **            k_final: number of final results to return (default 20)
 **            alpha:   blending factor for trigram vs semantic (default 0.5)
{%- if embedding_config.filter_params %}
{%- for param in embedding_config.filter_params %}
 **            {{ param.name }}: {{ param.description | default('filter parameter') }}
{%- endfor %}
{%- endif %}
 ****************************************************************************************************/
 
drop function if exists authority.search_{{ entity_key }}_hybrid(text, vector, integer, integer, integer, double precision{% for param in embedding_config.filter_params | default([]) %}, {{ param.type }}{% endfor %}) cascade;

create or replace function authority.search_{{ entity_key }}_hybrid(
  p_text text,
  qemb vector,
  k_trgm integer default 30,
  k_sem integer default 30,
  k_final integer default 20,
  alpha double precision default 0.5{% for param in embedding_config.filter_params | default([]) %},
  {{ param.name }} {{ param.type }} default {{ param.default }}{% endfor %}
) returns table (
  {{ entity.id_column }} integer,
  label text,
  trgm_sim double precision,
  sem_sim double precision,
  blend double precision
) language sql stable
as $$
  with params as (
    select authority.immutable_unaccent(lower(p_text))::text as q
  )
{%- if embedding_config.filter_params %}
  , filter_params as (
{%- for param in embedding_config.filter_params %}
    {{ param.cte_definition | indent(4) }}{% if not loop.last %},{% endif %}
{%- endfor %}
  )
{%- endif %}
  , trgm as (
    select
      e.{{ entity.id_column }},
      e.label,
      greatest(
        case when e.norm_label = pq.q then 1.0
            else similarity(e.norm_label, pq.q)
        end, 0.0001
      ) as trgm_sim
    from authority.{{ entity_key }} as e
    cross join params pq
{%- if embedding_config.filter_params %}
{%- for param in embedding_config.filter_params %}
    {{ param.join_clause | indent(4) }}
{%- endfor %}
{%- endif %}
    where e.norm_label % pq.q
{%- if embedding_config.filter_params %}
{%- for param in embedding_config.filter_params %}
      {{ param.where_clause | indent(6) }}
{%- endfor %}
{%- endif %}
    order by trgm_sim desc, e.label
    limit k_trgm
  )
  , sem as (
    select
      e.{{ entity.id_column }},
      e.label,
      (1.0 - (e.emb <=> qemb))::double precision as sem_sim
    from authority.{{ entity_key }} as e
{%- if embedding_config.filter_params %}
{%- for param in embedding_config.filter_params %}
    {{ param.join_clause | indent(4) }}
{%- endfor %}
{%- endif %}
    where e.emb is not null
{%- if embedding_config.filter_params %}
{%- for param in embedding_config.filter_params %}
      {{ param.where_clause | indent(6) }}
{%- endfor %}
{%- endif %}
    order by e.emb <=> qemb
    limit k_sem
  )
  , u as (
    select {{ entity.id_column }}, label, trgm_sim, null::double precision as sem_sim from trgm
    union
    select {{ entity.id_column }}, label, null::double precision as trgm_sim, sem_sim from sem
  )
  , agg as (
    select
      {{ entity.id_column }},
      max(label) as label,
      max(trgm_sim) as trgm_sim,
      max(sem_sim) as sem_sim
    from u
    group by {{ entity.id_column }}
  )
  select
    {{ entity.id_column }},
    label,
    coalesce(trgm_sim, 0.0) as trgm_sim,
    coalesce(sem_sim, 0.0) as sem_sim,
    (alpha * coalesce(trgm_sim, 0.0) + (1.0 - alpha) * coalesce(sem_sim, 0.0)) as blend
  from agg
  order by blend desc, label
  limit k_final;
$$;
