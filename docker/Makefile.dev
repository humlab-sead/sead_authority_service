SHELL := /bin/bash

###################################################################################################
# Detect whether to use podman or docker
###################################################################################################
ifeq (, $(shell command -v podman 2>/dev/null))
  CONTAINER_CMD := docker
else
  CONTAINER_CMD := podman
endif
$(info Using container command: $(CONTAINER_CMD))

###################################################################################################
# BUILD_ENV check (must be 'production' or 'staging')
###################################################################################################

ifeq ($(filter help apa tools,$(MAKECMDGOALS)),)
  ifeq ($(BUILD_ENV),production)
    $(info APP_ENVIRONMENT set to production)
  else ifeq ($(BUILD_ENV),staging)
    $(info APP_ENVIRONMENT set to staging)
  else
    $(info usage: make -e BUILD_ENV=staging|production.)
    $(error BUILD_ENV must be set to either 'staging' or 'production')
  endif
  ifeq (,$(wildcard ./compose/$(BUILD_ENV)/.env))
    $(error ./compose/$(BUILD_ENV)/.env not found!)
  endif
  include ./compose/$(BUILD_ENV)/.env
  export
  ifndef APP_BACKEND_TAG
    $(error APP_BACKEND_TAG is undefined)
  endif
  ifndef APP_FRONTEND_TAG
    $(error APP_FRONTEND_TAG is undefined)
  endif
else
BUILD_ENV:=staging
endif

include ./compose/$(BUILD_ENV)/.env
export

include .env-ghcr
export

###################################################################################################
# Publish the image to the GHCR registry
###################################################################################################
.PHONY: publish
ghcr-image:
	@echo "Building image $(APP_IMAGE_NAME):$(APP_BACKEND_TAG) for GHCR…"
	@$(CONTAINER_CMD) build \
		--build-arg APP_PORT=$(APP_PORT) \
		--build-arg APP_BACKEND_TAG=$(APP_BACKEND_TAG) \
		--build-arg APP_FRONTEND_TAG=$(APP_FRONTEND_TAG) \
		-t $(APP_IMAGE_NAME):$(APP_BACKEND_TAG) \
		-f ./Dockerfile .
apa:
	@echo "Publishing image $(APP_IMAGE_NAME):$(APP_BACKEND_TAG) to GHCR…"
	@cat ~/.ghcr_token | $(CONTAINER_CMD) login ghcr.io --username "$(GHCR_USERNAME)" --password-stdin

###################################################################################################
# Help target
###################################################################################################
.DEFAULT_GOAL := help
.PHONY: help
help:
	@echo "Usage: make [target]"
	@echo ""
	@echo "Primary targets:"
	@echo "  help              - Show this help"
	@echo "  image             - Build frontend, backend and image"
	@echo ""
	@echo "Secondary targets:"
	@echo "  backend           - Build backend if APP_BACKEND_TAG isn't a semver version, and not 'workdir' or branch or tag"
	@echo "  run-bash          - Run bash in container"
	@echo "  bash              - Exec bash in running container"
	@echo "  logs              - Follow logs of running container"
	@echo "  add-host-user     - Add host user 'swedeb'"
	@echo "  tools             - Install development tools (nvm, pnpm, etc.)"
	@echo "  up                - Bring up services via compose"
	@echo "  down              - Tear down services via compose"
	@echo "  restart           - Restart services (down → up)"
	@echo "  install-systemd   - Install systemd unit (Podman only)"
	@echo ""
	@echo "Environment variables:"
	@echo "  APP_ENVIRONMENT: the current environment (staging, production)"
	@echo "  APP_BACKEND_TAG: the backend version to deploy (branch, tag, commit, or 'workdir')"
	@echo "  APP_BACKEND_SOURCE: where to get backend ('workdir', 'pypi', or 'git')"
	@echo "  APP_IMAGE_NAME: the base image name"
	@echo "  APP_CONTAINER_NAME: the running container name (APP_ENVIRONMENT will be appended)"
	@echo "  APP_IMAGE_TAG: the target image tag (staging or backend-tag)"
	@echo "  APP_PORT: the port to expose the container on (inside)"
	@echo "  APP_HOST_PORT: the host port to expose the container on"
	@echo "  APP_SUBNET: the subnet to use for the container network"
	@echo "  APP_CONFIG_PATH: the config file to mount into the container"
	@echo ""
	@echo "Current environment values:"
	@echo "  BUILD_ENV=$(BUILD_ENV)"
	@echo "  APP_ENVIRONMENT=$${APP_ENVIRONMENT}"
	@echo "  APP_BACKEND_TAG=$${APP_BACKEND_TAG}"
	@echo "  APP_BACKEND_SOURCE=$${APP_BACKEND_SOURCE}"
	@echo "  APP_IMAGE_NAME=$${APP_IMAGE_NAME}"
	@echo "  APP_CONTAINER_NAME=$${APP_CONTAINER_NAME}"
	@echo "  APP_IMAGE_TAG=$${APP_IMAGE_TAG}"
	@echo "  APP_PORT=$${APP_PORT}"
	@echo "  APP_HOST_PORT=$${APP_HOST_PORT}"
	@echo "  APP_SUBNET=$${APP_SUBNET}"
	@echo "  APP_CONFIG_PATH=$${APP_CONFIG_PATH}"


###################################################################################################
# Temporary build directory for frontend/backend
###################################################################################################
SHA_FILE        := public/.frontend_last_built_sha
BACKEND_REPO    := https://github.com/humlab-sead/sead_authority_service.git
TMPDIR_BUILD    := /tmp/sas-build-${USER}


###################################################################################################
# Backend build target
###################################################################################################
.ONESHELL: backend
.PHONY: backend
backend: create-tmpdir
	@echo "Determining backend build method for $(APP_BACKEND_TAG)..."
	@if [ "$(APP_BACKEND_SOURCE)" == "workdir" ]; then \
		echo "Building backend API using $(APP_BACKEND_TAG) from workdir..."; \
		uv build --directory .. --output docker/dist ; \
	elif [ "$(APP_BACKEND_SOURCE)" == "git" ]; then \
		echo "Building backend API using git tag $(APP_BACKEND_TAG)..."; \
		pushd . > /dev/null && \
		mkdir -p $(TMPDIR_BUILD) && cd $(TMPDIR_BUILD) && \
		git clone $(BACKEND_REPO) --branch $(APP_BACKEND_TAG) --depth 1 && \
		cd sead_authority_service && \
		uv build && \
		popd > /dev/null && \
		rm -rf dist && \
		mv -f $(TMPDIR_BUILD)/sead_authority_service/dist dist && \
		rm -rf $(TMPDIR_BUILD); \
	fi

###################################################################################################
# Build & tag the container image
###################################################################################################
.PHONY: image
.ONESHELL: image
image: backend
	@echo "Building $${APP_ENVIRONMENT^^} image using $(APP_BACKEND_TAG)..."
	@$(CONTAINER_CMD) build \
		--build-arg APP_PORT=$(APP_PORT) \
		--build-arg APP_BACKEND_TAG=$(APP_BACKEND_TAG) \
		--build-arg APP_FRONTEND_TAG=$(APP_FRONTEND_TAG) \
		--build-arg NODE_VERSION=24 \
		-t $(APP_IMAGE_NAME):$(APP_IMAGE_TAG) \
		-t $(APP_IMAGE_NAME):$(APP_BACKEND_TAG) \
		-f ./Dockerfile .
	@echo "Done building image $(APP_IMAGE_NAME):$(APP_BACKEND_TAG)"

###################################################################################################
# Create temporary build directory
###################################################################################################
.PHONY: create-tmpdir
create-tmpdir:
	@rm -rf $(TMPDIR_BUILD) && mkdir -p $(TMPDIR_BUILD)

###################################################################################################
# Run a one-off bash shell in the container (without starting it)
###################################################################################################
.PHONY: run-bash
run-bash:
	@$(CONTAINER_CMD) run -it --rm \
	  --env-file ./compose/.env.$(BUILD_ENV) \
	  --entrypoint /bin/bash \
	  $(APP_IMAGE_NAME):$(APP_BACKEND_TAG)

###################################################################################################
# Exec bash inside running container
###################################################################################################
.PHONY: bash
bash:
	@$(CONTAINER_CMD) exec -it $(APP_CONTAINER_NAME)-$(APP_ENVIRONMENT) /bin/bash

###################################################################################################
# Follow container logs
###################################################################################################
.PHONY: logs
logs:
	@$(CONTAINER_CMD) logs $(APP_CONTAINER_NAME)-$(APP_ENVIRONMENT) --follow

###################################################################################################
# Bring up services via Docker/Podman Compose
###################################################################################################
.PHONY: up
up:
	@$(CONTAINER_CMD) compose -f ./compose/$(BUILD_ENV)/compose.yml up -d

###################################################################################################
# Tear down services via Docker/Podman Compose
###################################################################################################
.PHONY: down
down:
	@$(CONTAINER_CMD) compose -f ./compose.yml down

###################################################################################################
# Restart services (down → up)
###################################################################################################
.PHONY: restart
restart: down up
	@echo "Daemon restarted."

# ###################################################################################################
# # Systemd integration (Podman only)
# ###################################################################################################
# SYSTEMD_USER_DIR    := $(HOME)/.config/systemd/user
# FULL_CONTAINER_NAME := $(APP_CONTAINER_NAME)-$(APP_ENVIRONMENT)
# UNIT_NAME           := $(FULL_CONTAINER_NAME).service

# .PHONY: install-systemd
# install-systemd:
# ifeq ($(CONTAINER_CMD),podman)
# 	@echo "→ Generating systemd unit for container '$(FULL_CONTAINER_NAME)'"
# 	@mkdir -p "$(SYSTEMD_USER_DIR)"
# 	@podman generate systemd --new --name "$(FULL_CONTAINER_NAME)" \
# 	  | sed "s/^# \\(Description=.*\\)/# \\1\n# Autogenerated by Makefile/" \
# 	  > "$(SYSTEMD_USER_DIR)/$(UNIT_NAME)" \
# 	  && echo "   → Unit written to $(SYSTEMD_USER_DIR)/$(UNIT_NAME)"
# 	@echo "→ Reloading user systemd daemon"
# 	@systemctl --user daemon-reload
# 	@echo "→ Enabling unit: $(UNIT_NAME)"
# 	@systemctl --user enable "$(UNIT_NAME)"
# 	@echo "→ Starting unit: $(UNIT_NAME)"
# 	@systemctl --user start  "$(UNIT_NAME)"
# 	@if [ "$(ENABLE_LINGER)" != "no" ]; then \
# 		echo "→ Enabling lingering for user $$(id -u)"; \
# 		sudo loginctl enable-linger $$(id -u) || echo "   (lingering may already be enabled)"; \
# 	fi
# 	@echo "✔ systemd integration installed. Run 'systemctl --user status $(UNIT_NAME)' to verify."
# else
# 	@echo "install-systemd is only supported when using Podman. Current command: $(CONTAINER_CMD)"
# endif

