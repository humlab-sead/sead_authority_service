# Docker configuration for SEAD Authority Service
# This config file is mounted into the container
# It contains production-safe defaults with environment variable substitution

options:
  id_base: "https://w3id.org/sead/id/"
  auto_accept_threshold: 0.90
  default_query_limit: 10
  database:
    dbname: "${SEAD_AUTHORITY_OPTIONS_DATABASE_DBNAME:-sead_staging}"
    host: "${SEAD_AUTHORITY_OPTIONS_DATABASE_HOST:-localhost}"
    port: "${SEAD_AUTHORITY_OPTIONS_DATABASE_PORT:-5432}"
    user: "${SEAD_AUTHORITY_OPTIONS_DATABASE_USER:-sead_user}"

policy:
  site:
    proximity_boost:
      very_near_distance_km: 0.2
      to_far_distance_km: 10.0
    place_name_similarity_boost:
      similarity_threshold: 0.3
      max_boost: 0.1
  modification_type:
    lookup_format: "json"
    lookup_fields_map:
      id: "modification_type_id"
      label: "modification_type_name"
      description: "modification_type_description"
    entity_type_description: "modification type"
    roles: 
      - role: system
        content: You are archaeological specialist with expertise in identifying and classifying archaeological samples based on their features and characteristics.
    context: |
      You are provided with known modification types, each with an id, a label and a description.
    output:
      format: json
  geonames:
    options:
      username: "${GEONAMES_USERNAME:-demo}"
      lang: "en"
      country_bias: "en"
      fuzzy: 0.8
      feature_classes: ["P", "A"]
      orderby: "relevance"
      style: "FULL"

llm:
  provider: "${LLM_PROVIDER:-openai}"
  options:
    max_tokens: 10000
    temperature: 0.1
  enable_translation: true
  enable_semantic_matching: true
  translation_target_lang: "en"
  semantic_batch_size: 50
  openai:
    model: "${OPENAI_MODEL:-gpt-4o-mini}"
    provider_id: "openapi"
    api_key: "${OPENAI_API_KEY}"
    options:
      temperature: 0.1
      max_tokens: 4096
      stream: false
  ollama:
    provider_id: "ollama"
    model: "${OLLAMA_MODEL:-gpt-oss:20b}"
    host: "${OLLAMA_BASE_URL:-http://localhost:11434}"
    timeout: 30
    options:
      temperature: 0.1
      num_predict: 4096
  anthropic:
    provider_id: "anthropic"
    model: "${ANTHROPIC_MODEL:-claude-2}"
    api_key: "${ANTHROPIC_API_KEY}"
    options:
      temperature: 0.1
      max_tokens: 1000
  prompts:
    language_detection: |
      Detect the language of the following text. Respond with the ISO 639-1 language code (e.g., "en" for English, "fr" for French, "de" for German, "sv" for Swedish).

      Text:
      "{text}"

    translation: |
      Translate the following text line by line from {source_lang} to {target_lang}.

      Context:
      {context}

      Guidelines:
      - Keep the translation natural and fluent.
      - Preserve proper nouns, names, and technical terms when appropriate.
      - Use the most common or widely recognized form in the target language if one exists.
      - Maintain the same number of lines as the input.

      Text to translate:
      {text}

    abbreviation: |
      Expand the following abbreviations line by line.

      Each line in the input follows the format:
      "id, abbreviation"

      The text may include multiple languages.
      
      {context}

      Your task:
      - Expand each abbreviation into its full form based on the given context.
      - Preserve proper nouns, names, and original capitalization when appropriate.
      - Output one line per input line, using the format:
        "id, expanded-abbreviation"

      Input abbreviations:
      {data}

    reconciliation: |
      You are reconciling input values against a controlled list of {{ entity_type }}.
      Return ONLY strict JSON. No prose.

      Context:
      {{ context }}

      Lookup data ({{ lookup_format }} objects with fields: id, label, description):
      {{ lookup_data | safe }}

      Input values ({{ lookup_format }}, preserve order):
      {{ data | safe }}

      Task:
      For each input, return up to 5 candidate matches from the lookup, ordered best→worst.

      Output JSON must be an array where each element is:
      {
        "input_id": "<string>",
        "input_value": "<string>",
        "candidates": [
          { "id": "<lookup id as string>", "value": "<lookup label verbatim>", "score": 0.00, "reasons": ["...","..."] }
        ]
      }

      {{ examples | safe }}

      Rules:
      - Use ONLY ids/labels from the lookup (do not invent).
      - Copy the lookup's **label** into the candidate **value** verbatim.
      - If no reasonable match, return "candidates": [].
      - Scores are in [0,1], **rounded to two decimals**.
      - Provide **2–4 short** reason bullets per candidate.
      - Treat text comparison as **case- and diacritic-insensitive**.
      - Return **ONLY** valid JSON (no comments, no trailing commas, no extra text).

      Scoring considerations:
      - String similarity (normalization, diacritics, casing)
      - Abbreviation/alias/lemmatization expansion
      - Domain/context alignment (terminology fit)
      - Language variants and most common target-language form
      - Penalize partial/ambiguous overlaps and mismatched domain terms

geonames:
  options:
    username: "${GEONAMES_USERNAME:-demo}"
    lang: "en"
    country_bias: "en"
    fuzzy: 0.8
    feature_classes: ["P", "A"]
    orderby: "relevance"
    style: "FULL"

logging:
  folder: ./logs
  handlers:
    - sink: "sead_authority.log"
      level: "INFO"
      format: "{time:YYYY-MM-DD HH:mm:ss} | {level} | {message}"
      rotation: "10 MB"
      retention: "30 days"
    - sink: "sys.stdout"
      level: "INFO"
      format: "{time:YYYY-MM-DD HH:mm:ss} | {level} | {message}"
